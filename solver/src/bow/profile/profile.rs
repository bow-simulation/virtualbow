use nalgebra::SVector;
use crate::fem::elements::beam::PlanarCurve;
use crate::bow::errors::ModelError;
use crate::bow::profile::input::SegmentInput;
use crate::numerics::bisection::bisect_right_by;

#[derive(Copy ,Clone, PartialEq)]
pub struct CurvePoint {
    pub s: f64,                // Arc length
    pub φ: f64,                // Tangent angle
    pub r: SVector<f64, 2>,    // Position (x, y)
}

impl CurvePoint {
    pub fn new(s: f64, φ: f64, r: SVector<f64, 2>) -> CurvePoint {
        CurvePoint {
            s,
            φ,
            r
        }
    }

    pub fn zero() -> CurvePoint {
        CurvePoint {
            s: 0.0,
            φ: 0.0,
            r: SVector::zeros()
        }
    }
}

pub struct ProfileCurve {
    segments: Vec<Box<dyn PlanarCurve>>,    // List of segments that make up the profile curve
    nodes: Vec<CurvePoint>,                 // List of nodes at the start and end of each segment
}

impl ProfileCurve {
    pub fn new(start: CurvePoint, segment_inputs: &Vec<SegmentInput>) -> Result<ProfileCurve, ModelError> {
        if segment_inputs.is_empty() {
            return Err(ModelError::ProfileNoSegments);
        }

        let mut nodes = Vec::with_capacity(segment_inputs.len() + 1);
        let mut segments = Vec::with_capacity(segment_inputs.len());

        // The first node is the starting point
        nodes.push(start);

        // Create curve segments for each model in the list, using the currently last node as the starting point.
        // Add each segment's endpoint to the nodes as the starting point for the next segment.
        for (index, input) in segment_inputs.iter().enumerate() {
            input.validate(index)?;
            let segment = input.create(nodes.last().unwrap());
            let endpoint = CurvePoint::new(segment.s_end(), segment.angle(segment.s_end()), segment.position(segment.s_end()));
            nodes.push(endpoint);
            segments.push(segment);
        }

        Ok(Self{
            segments,
            nodes,
        })
    }

    fn find_segment_index(&self, s: f64) -> usize {
        bisect_right_by(&self.nodes, |point| point.s.partial_cmp(&s).expect("Failed to compare floating point values"))
    }
}

impl PlanarCurve for ProfileCurve {
    fn s_start(&self) -> f64 {
        self.segments.first().unwrap().s_start()    // Ensured by construction
    }

    fn s_end(&self) -> f64 {
        self.segments.last().unwrap().s_end()    // Ensured by construction
    }

    fn curvature(&self, s: f64) -> f64 {
        let index = self.find_segment_index(s);
        self.segments[index].curvature(s)
    }

    fn angle(&self, s: f64) -> f64 {
        let index = self.find_segment_index(s);
        self.segments[index].angle(s)
    }

    fn position(&self, s: f64) -> SVector<f64, 2> {
        let index = self.find_segment_index(s);
        self.segments[index].position(s)
    }
}

#[cfg(test)]
mod tests {
    use iter_num_tools::lin_space;
    use nalgebra::vector;
    use crate::bow::profile::segments::clothoid::{ArcInput, LineInput, SpiralInput};
    use crate::bow::profile::segments::spline::SplineInput;
    use super::*;

    #[test]
    fn test_profile_curve() {
        // Creates a profile curve that contains all available segment types and compares the result
        // with the output of VirtualBow 0.9 to ensure compatiblity with the C++ implementation.
        // Once the new solver evolves on its own, this test can be removed or modified.

        let x_ref = &[0.000000, 2.020200, 4.040400, 6.060610, 8.080810, 10.101000, 12.121200, 14.141400, 16.161600, 18.181800, 20.202000, 22.222200, 24.242400, 26.262600, 28.282800, 30.303000, 32.323200, 34.343400, 36.363600, 38.383800, 40.404000, 42.424200, 44.444400, 46.464600, 48.484800, 50.505100, 52.525300, 54.545500, 56.565700, 58.585900, 60.606100, 62.626300, 64.646500, 66.666700, 68.686900, 70.707100, 72.727300, 74.747500, 76.767700, 78.787900, 80.808100, 82.828300, 84.848500, 86.868700, 88.888900, 90.909100, 92.929300, 94.949500, 96.969700, 98.989900, 101.010000, 103.030000, 105.051000, 107.071000, 109.091000, 111.111000, 113.131000, 115.152000, 117.172000, 119.192000, 121.212000, 123.232000, 125.253000, 127.273000, 129.293000, 131.313000, 133.333000, 135.354000, 137.374000, 139.394000, 141.414000, 143.434000, 145.455000, 147.475000, 149.495000, 151.515000, 153.535000, 155.556000, 157.576000, 159.596000, 161.616000, 163.636000, 165.657000, 167.677000, 169.697000, 171.717000, 173.737000, 175.758000, 177.778000, 179.798000, 181.818000, 183.838000, 185.859000, 187.879000, 189.899000, 191.919000, 193.939000, 195.960000, 197.980000, 200.000000, 200.000000, 202.020000, 204.040000, 206.060000, 208.080000, 210.100000, 212.120000, 214.140000, 216.159000, 218.178000, 220.197000, 222.215000, 224.233000, 226.251000, 228.268000, 230.284000, 232.301000, 234.316000, 236.332000, 238.346000, 240.360000, 242.373000, 244.386000, 246.398000, 248.409000, 250.419000, 252.429000, 254.437000, 256.445000, 258.452000, 260.458000, 262.463000, 264.467000, 266.469000, 268.471000, 270.472000, 272.471000, 274.469000, 276.466000, 278.462000, 280.457000, 282.450000, 284.442000, 286.432000, 288.421000, 290.409000, 292.395000, 294.380000, 296.363000, 298.344000, 300.324000, 302.303000, 304.279000, 306.254000, 308.227000, 310.199000, 312.168000, 314.136000, 316.102000, 318.066000, 320.028000, 321.988000, 323.947000, 325.903000, 327.857000, 329.809000, 331.759000, 333.706000, 335.652000, 337.595000, 339.536000, 341.475000, 343.412000, 345.346000, 347.278000, 349.207000, 351.134000, 353.058000, 354.980000, 356.900000, 358.817000, 360.731000, 362.643000, 364.552000, 366.458000, 368.361000, 370.262000, 372.160000, 374.056000, 375.948000, 377.838000, 379.724000, 381.608000, 383.489000, 385.366000, 387.241000, 389.113000, 390.981000, 392.847000, 394.709000, 394.709000, 396.573000, 398.443000, 400.319000, 402.201000, 404.089000, 405.983000, 407.881000, 409.786000, 411.695000, 413.609000, 415.529000, 417.453000, 419.381000, 421.314000, 423.252000, 425.194000, 427.139000, 429.089000, 431.043000, 433.000000, 434.961000, 436.925000, 438.893000, 440.864000, 442.838000, 444.815000, 446.795000, 448.777000, 450.763000, 452.750000, 454.741000, 456.733000, 458.728000, 460.725000, 462.724000, 464.724000, 466.727000, 468.731000, 470.737000, 472.744000, 474.753000, 476.763000, 478.775000, 480.787000, 482.801000, 484.816000, 486.831000, 488.847000, 490.864000, 492.882000, 494.900000, 496.919000, 498.938000, 500.958000, 502.977000, 504.997000, 507.018000, 509.038000, 511.058000, 513.078000, 515.098000, 517.118000, 519.137000, 521.157000, 523.176000, 525.194000, 527.212000, 529.229000, 531.246000, 533.262000, 535.278000, 537.293000, 539.307000, 541.320000, 543.332000, 545.343000, 547.354000, 549.363000, 551.371000, 553.378000, 555.385000, 557.390000, 559.393000, 561.396000, 563.397000, 565.397000, 567.396000, 569.393000, 571.389000, 573.383000, 575.376000, 577.368000, 579.358000, 581.346000, 583.333000, 585.319000, 587.303000, 589.285000, 591.266000, 591.266000, 592.836000, 594.399000, 595.962000, 597.523000, 599.082000, 600.641000, 602.199000, 603.757000, 605.314000, 606.871000, 608.427000, 609.984000, 611.541000, 613.097000, 614.654000, 616.211000, 617.768000, 619.325000, 620.883000, 622.441000, 623.999000, 625.558000, 627.117000, 628.676000, 630.236000, 631.796000, 633.357000, 634.919000, 636.481000, 638.043000, 639.607000, 641.170000, 642.735000, 644.300000, 645.866000, 647.433000, 649.000000, 650.568000, 652.137000, 653.707000, 655.278000, 656.849000, 658.422000, 659.995000, 661.570000, 663.145000, 664.722000, 666.300000, 667.878000, 669.458000, 671.039000, 672.622000, 674.205000, 675.790000, 677.376000, 678.964000, 680.553000, 682.143000, 683.735000, 685.328000, 686.923000, 688.519000, 690.117000, 691.715000, 693.316000, 694.917000, 696.518000, 698.120000, 699.723000, 701.324000, 702.924000, 704.523000, 706.119000, 707.712000, 709.300000, 710.882000, 712.456000, 714.021000, 715.575000, 717.115000, 718.639000, 720.145000, 721.628000, 723.087000, 724.519000, 725.920000, 727.289000, 728.623000, 729.922000, 731.185000, 732.411000, 733.604000, 734.764000, 735.896000, 737.002000, 738.087000, 739.156000, 740.214000, 741.266000];
        let y_ref = &[0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.004081, -0.016325, -0.036731, -0.065298, -0.102027, -0.146917, -0.199966, -0.261175, -0.330542, -0.408066, -0.493746, -0.587580, -0.689567, -0.799705, -0.917993, -1.044430, -1.179010, -1.321730, -1.472600, -1.631600, -1.798740, -1.974010, -2.157410, -2.348940, -2.548590, -2.756370, -2.972260, -3.196260, -3.428380, -3.668600, -3.916920, -4.173350, -4.437860, -4.710470, -4.991160, -5.279940, -5.576790, -5.881710, -6.194700, -6.515740, -6.844850, -7.182010, -7.527210, -7.880450, -8.241720, -8.611020, -8.988350, -9.373690, -9.767040, -10.168400, -10.577700, -10.995100, -11.420400, -11.853700, -12.295000, -12.744200, -13.201400, -13.666500, -14.139600, -14.620600, -15.109500, -15.606300, -16.111100, -16.623700, -17.144300, -17.672700, -18.209000, -18.753100, -19.305100, -19.865000, -20.432700, -21.008200, -21.591600, -22.182700, -22.781700, -23.388500, -24.003000, -24.625300, -25.255300, -25.893200, -26.538700, -27.192000, -27.853000, -28.521700, -29.198100, -29.882200, -30.574000, -31.273400, -31.980500, -32.695200, -33.417500, -34.147500, -34.885100, -35.630200, -36.383000, -37.143300, -37.911100, -38.686600, -39.469500, -39.469500, -40.248700, -41.012900, -41.762100, -42.496300, -43.215600, -43.920100, -44.609600, -45.284400, -45.944300, -46.589500, -47.220000, -47.835900, -48.437100, -49.023700, -49.595800, -50.153400, -50.696600, -51.225400, -51.739900, -52.240000, -52.726000, -53.197700, -53.655400, -54.098900, -54.528500, -54.944100, -55.345800, -55.733700, -56.107900, -56.468300, -56.815100, -57.148300, -57.468100, -57.774300, -58.067300, -58.346900, -58.613200, -58.866400, -59.106500, -59.333600, -59.547800, -59.749000, -59.937500, -60.113200, -60.276300, -60.426800, -60.564800, -60.690400, -60.803700, -60.904600, -60.993400, -61.070100, -61.134700, -61.187400, -61.228200, -61.257300, -61.274600, -61.280300, -61.274500, -61.257200, -61.228500, -61.188500, -61.137300, -61.075000, -61.001700, -60.917400, -60.822200, -60.716200, -60.599600, -60.472300, -60.334500, -60.186200, -60.027600, -59.858700, -59.679600, -59.490400, -59.291300, -59.082100, -58.863200, -58.634500, -58.396100, -58.148200, -57.890700, -57.623900, -57.347800, -57.062400, -56.767900, -56.464300, -56.151800, -55.830400, -55.500200, -55.161300, -54.813800, -54.457800, -54.093300, -53.720500, -53.339400, -52.950200, -52.552800, -52.552800, -52.224100, -51.881200, -51.527400, -51.166400, -50.800100, -50.429700, -50.056400, -49.680900, -49.303800, -48.925600, -48.546700, -48.167400, -47.788100, -47.409000, -47.030300, -46.652300, -46.275000, -45.898700, -45.523600, -45.149800, -44.777300, -44.406500, -44.037300, -43.670000, -43.304600, -42.941300, -42.580200, -42.221400, -41.865100, -41.511300, -41.160200, -40.812000, -40.466700, -40.124600, -39.785700, -39.450300, -39.118400, -38.790200, -38.466000, -38.145800, -37.830000, -37.518600, -37.212000, -36.910300, -36.613800, -36.322800, -36.037500, -35.758300, -35.485600, -35.219500, -34.960700, -34.709400, -34.466200, -34.231600, -34.006200, -33.790600, -33.585500, -33.391700, -33.210100, -33.041700, -32.887700, -32.749400, -32.628300, -32.526200, -32.444800, -32.385400, -32.349400, -32.338300, -32.353400, -32.396700, -32.469800, -32.574600, -32.713300, -32.888000, -33.101000, -33.354600, -33.651400, -33.993700, -34.384100, -34.825000, -35.318600, -35.866700, -36.471000, -37.132400, -37.851500, -38.627700, -39.460200, -40.346800, -41.285000, -42.271300, -43.301600, -44.371500, -45.476100, -46.610500, -47.769600, -48.948400, -50.141800, -51.344900, -52.552800];

        let input = vec![
            SegmentInput::Line(LineInput::new(0.2)),
            SegmentInput::Arc(ArcInput::new(0.2, -0.5)),
            SegmentInput::Spiral(SpiralInput::new(0.2, 0.25, 0.5)),
            SegmentInput::Spline(SplineInput::new(vec![[0.0, 0.0], [0.1, 0.02], [0.15, 0.0]])),
        ];

        let profile = ProfileCurve::new(CurvePoint::zero(), &input).unwrap();

        let iter = lin_space(profile.nodes[0].s..=profile.nodes[1].s, 100)
            .chain(lin_space(profile.nodes[1].s..=profile.nodes[2].s, 100))
            .chain(lin_space(profile.nodes[2].s..=profile.nodes[3].s, 100))
            .chain(lin_space(profile.nodes[3].s..=profile.nodes[4].s, 100));

        for (i, s) in iter.enumerate() {
            assert_relative_eq!(profile.position(s), vector![1e-3*x_ref[i], 1e-3*y_ref[i]], max_relative=1e-4);
        }
    }
}